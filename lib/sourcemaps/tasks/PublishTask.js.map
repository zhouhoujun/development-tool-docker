{"version":3,"sources":["tasks/PublishTask.ts"],"names":["_","require","development_core_1","replace","NodeDynamicTasks","this","publishImages","prototype","getServiceInfo","ctx","_info","option","imgs","toSrc","images","isArray","service","env","publish","toStr","user","psw","tasks","_this","name","shell","cmds","dist","toUrl","getRootPath","buildcmd","test","first","split","info","version","pkg","getPackage","each","it","pimg","push","substring","lastIndexOf","pushcmd","map","mg","pipes","img","idx","exportcmd","exportImagecmd","path","getDist","exportImage","__decorate","dynamicTask","exports"],"mappings":"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","file":"../../tasks/PublishTask.js","sourcesContent":["\r\nimport * as _ from 'lodash';\r\n// import * as path from 'path';\r\nimport { IDynamicTaskOption, IDynamicTasks, dynamicTask, ITaskContext } from 'development-core';\r\n// import * as chalk from 'chalk';\r\nimport { DockerOption } from '../DockerOption';\r\nconst replace = require('gulp-replace');\r\n\r\nexport interface ServiceInfo {\r\n    images: string[];\r\n    service: string;\r\n    user: string;\r\n    psw: string;\r\n}\r\n\r\n@dynamicTask\r\nexport class NodeDynamicTasks implements IDynamicTasks {\r\n    private publishImages = [];\r\n\r\n    private _info: ServiceInfo;\r\n    protected getServiceInfo(ctx: ITaskContext) {\r\n        if (!this._info) {\r\n            let option = ctx.option as DockerOption;\r\n            let imgs = ctx.toSrc(option.images);\r\n            this._info = <ServiceInfo>{\r\n                images: _.isArray(imgs) ? imgs : [imgs],\r\n                service: ctx.env.publish || ctx.toStr(option.service),\r\n                user: ctx.env['user'] || ctx.toStr(option.user),\r\n                psw: ctx.env['psw'] || ctx.toStr(option.psw),\r\n            };\r\n        }\r\n        return this._info;\r\n    }\r\n\r\n    tasks(): IDynamicTaskOption[] {\r\n        return [\r\n            {\r\n                name: 'build-docker',\r\n                shell: (ctx) => {\r\n                    let cmds = '';\r\n                    let dist = ctx.toUrl(ctx.getRootPath());\r\n                    let option = ctx.option as DockerOption;\r\n                    let buildcmd = ctx.toStr(option.buildcmd) || 'docker-compose down & docker-compose build';\r\n                    if (/^[C-Z]:/.test(dist)) {\r\n                        cmds = _.first(dist.split(':')) + ': & ';\r\n                    }\r\n                    cmds = cmds + `cd ${dist} & ${buildcmd}`;\r\n                    return cmds;\r\n                }\r\n\r\n            },\r\n            {\r\n                name: 'tag-docker',\r\n                shell: (ctx) => {\r\n                    let info = this.getServiceInfo(ctx);\r\n                    let cmds = '';\r\n\r\n                    let option = ctx.option as DockerOption;\r\n                    let version = '';\r\n                    if (option.version) {\r\n                        version = ctx.toStr(option.version);\r\n                    } else {\r\n                        let pkg = ctx.getPackage();\r\n                        if (pkg) {\r\n                            version = pkg.version;\r\n                        }\r\n                    }\r\n                    version = version || 'latest';\r\n\r\n                    _.each(info.images, it => {\r\n                        let pimg = info.service ? `${info.service}/${it}:${version}` : `${it}:${version}`;\r\n                        this.publishImages.push(pimg);\r\n                        cmds = cmds + `docker tag ${it} ${pimg} & `\r\n                    });\r\n\r\n                    cmds = cmds.substring(0, cmds.lastIndexOf('&'));\r\n                    return cmds;\r\n                }\r\n            },\r\n            {\r\n                name: 'push-docker',\r\n                shell: (ctx) => {\r\n                    let info = this.getServiceInfo(ctx);\r\n                    if (!info.service) {\r\n                        return '';\r\n                    }\r\n                    let option = ctx.option as DockerOption;\r\n                    let pushcmd = ctx.toStr(option.pushcmd) || 'docker push';\r\n                    return _.map(this.publishImages, mg => info.user ? `docker login -u ${info.user} -p ${info.psw} ${info.service} & ${pushcmd} ${mg}` : `${pushcmd} ${mg}`);\r\n                }\r\n            },\r\n            {\r\n                name: 'export-docker-compose',\r\n                pipes: (ctx) => {\r\n                    let info = this.getServiceInfo(ctx);\r\n                    let pipes = [(ctx) => replace(/build:/gi, '# build:'), (ctx) => replace(/#\\s*image:/gi, 'image:')];\r\n                    _.each(info.images, (img, idx) => {\r\n                        pipes.push(ctx => replace(img, this.publishImages[idx]));\r\n                    });\r\n                    return pipes;\r\n                }\r\n            },\r\n            {\r\n                name: 'save-docker-images',\r\n                shell: (ctx) => {\r\n                    let option = ctx.option as DockerOption;\r\n                    let info = this.getServiceInfo(ctx);\r\n                    let exportcmd = ctx.toStr(option.exportImagecmd) || 'docker save';\r\n                    let path = ctx.toUrl(ctx.getDist());\r\n                    return _.map(this.publishImages, (mg, idx) => option.exportImage ? ` ${exportcmd} ${mg} -o ${path}/${info.images[idx]}.tar` : ``);\r\n                }\r\n            }\r\n        ];\r\n    }\r\n}\r\n"]}